# -*- coding: utf-8 -*-
"""Codage par paires d'octets.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/gabilodeau/INF8770/blob/master/Codage%20par%20paires%20d'octets.ipynb

INF8770 Technologies multimédias

Polytechnique Montréal

Exemple de codage par paires d'octets
"""

import numpy as np
import regex as re
import time
from Result import CodeResult 

def algo(Message):
    """ Début du chronomètre"""
    start = time.time()

    """Vérification des octets utilisés. Utilisation d'une table pour faire le suivi."""

    LUToctetsdispo = [True] * 256
    dictsymb =[Message[0]]
    LUToctetsdispo[ord(Message[0])] = False
    nbsymboles = 1
    for i in range(1,len(Message)):
        if Message[i] not in dictsymb:
            dictsymb += [Message[i]]
            LUToctetsdispo[ord(Message[i])] = False  #Octet utilisé
            nbsymboles += 1
            
    longueurOriginale = np.ceil(np.log2(nbsymboles))*len(Message)   
    nboctets = len(Message)

    # """Codage du message"""

    dictsymb = []  #Dictionnaire des substitutions
    debut = ord(Message[0])  # Origine trouver un code de substitution. Et pour avoir des caractères imprimables...

    remplacementpossible = True
    while remplacementpossible == True:
        #Recherche des paires
        paires = []
        for i in range(0,len(Message)-1):
            temppaire = Message[i]+Message[i+1]
            if not list(filter(lambda x: x[0] == temppaire, paires)): #Si la liste retournée par filter est vide.
               
                
                paires += [[temppaire,len(re.findall(temppaire, Message, overlapped = True))]]
                
        #Trouve la paire avec le plus de répétitions.
        paires = sorted(paires, key=lambda x: x[1], reverse = True)

        if paires[0][1] > 1:
            #Remplace la paire

            #Cherche un octet non utilisé
            while debut <256 and LUToctetsdispo[debut] == False and chr(debut) in {"[", "]", "(", ")"}:
                debut += 1

            if debut < 256: 
                #On substitut
                Message = Message.replace(paires[0][0], chr(debut))
                LUToctetsdispo[debut] = False
                dictsymb += [[paires[0][0], chr(debut)]]
                nbsymboles += 1
            else:
                print("Il n'y a plus d'octets disponible!") #Bien sûr, ce n'est pas exact car la recherche commence à Message[0]
            
        else:
            remplacementpossible = False

    """ Fin chronomètre """
    end = time.time()
    temps = end - start
    # """Longueur en bits du message codé et celle de l'original"""

    print("Paires d'octets: ")


    print("Longueur = {0}".format(np.ceil(np.log2(nbsymboles))*len(Message)))
    print("Longueur originale = {0}".format(longueurOriginale))
    print("Temps d'exécution: " + str(end - start))


    print("Longueur octets = {0}".format(len(Message)))
    print("Longueur originale = {0}".format(nboctets))
    result = CodeResult(longueurOriginale, np.ceil(np.log2(nbsymboles))*len(Message), temps)
    return result
    # # """Mais si on suit strictement la définition du codage par paires d'octets, les longueurs en octets sont:"""
